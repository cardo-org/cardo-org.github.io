[
  {
    "objectID": "rust.html",
    "href": "rust.html",
    "title": "Rust",
    "section": "",
    "text": "Rust API coming soon.\nfn main() {\n    println!(\"Hello, Rembus!\");\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rembus",
    "section": "",
    "text": "The goal of Rembus is to be a messaging middleware for systems where the mains building blocks are scientific computing and components decoupling using microservices architectural patterns.\nIt is written in Julia but designed to exchange messages between components implemented in other languages.\nIt is a fresh approach to messaging: instead of requiring buffers or streams of bytes and loading the application with encoding/decoding tasks it accepts primitive types, dictionaries, lists and dataframes types through a thin API."
  },
  {
    "objectID": "index.html#rpc",
    "href": "index.html#rpc",
    "title": "Rembus",
    "section": "RPC",
    "text": "RPC\nRembus provides the request/reply pattern where a component request a service and another component implements and exposes such service.\nThere may be multiple components exposing the same service and different logics for routing the request to a specific server, implementing fail-over or balancing features."
  },
  {
    "objectID": "index.html#publishsubscribe",
    "href": "index.html#publishsubscribe",
    "title": "Rembus",
    "section": "Publish/Subscribe",
    "text": "Publish/Subscribe\nOne component produce a message and one or many interested subscribers receive it.\nWhen a component goes online again if the retroactive feature is enabled the component receives the messages published when it was offline."
  },
  {
    "objectID": "index.html#brokerless",
    "href": "index.html#brokerless",
    "title": "Rembus",
    "section": "Brokerless",
    "text": "Brokerless\nIn a simple scenario or where a Broker may be redundant or tought as a single point of failure a brokerless architecture consents peer to peer comunication between components."
  },
  {
    "objectID": "index.html#dataframes-support",
    "href": "index.html#dataframes-support",
    "title": "Rembus",
    "section": "DataFrames support",
    "text": "DataFrames support\nRembus uses the Arrow columnar format to transport dataframes messages between components.\nJulia, Python and Rust components may exchange dataframes betweeen DataFrames.jl, Pandas and Polars libraries."
  },
  {
    "objectID": "julia.html",
    "href": "julia.html",
    "title": "Julia",
    "section": "",
    "text": "Rembus.jl is the Julia implementation of Rembus specification: it provides a broker implementation and the API for Rembus components."
  },
  {
    "objectID": "julia.html#getting-started",
    "href": "julia.html#getting-started",
    "title": "Julia",
    "section": "Getting Started",
    "text": "Getting Started\nInstall the Rembus package and wait about a minute for downloading and precompilation steps.\njulia&gt; import Pkg; Pkg.add(\"Rembus\")\n   Resolving package versions...\n   Installed Rembus ─ v0.2.0\n   ...\nPrecompiling project...\n  1 dependency successfully precompiled in 73 seconds. 74 already precompiled.\n  1 dependency had output during precompilation:\n┌ Rembus\n│  [2024-05-18T10:36:22.538][Rembus][1][Info] caronte up and running at port tcp:8001\n│  [2024-05-18T10:36:23.722][Rembus][1][Info] caronte up and running at port zmq:8002\n│  [2024-05-18T10:36:23.951][Rembus][1][Info] caronte up and running at port ws:8000\n└  \n\njulia&gt;\nOnce the package is installed starts the broker:\nshell&gt; julia -e 'using Rembus; caronte()'\nThe following output shows when caronte broker start successfully:\n[2024-05-18T10:41:26.750][Rembus][1][Info] caronte up and running at port ws:8000\nBy default the broker accepts WebSocket connections on port 8000, but plain tcp sockets and ZeroMQ endpoints are possible.\nFor example start all the protocols with:\njulia -e 'using Rembus; caronte()' -- --ws 8000 --tcp 8001 --zmq 8002\n[2024-05-18T10:46:00.063][Rembus][1][Info] caronte up and running at port tcp:8001\n[2024-05-18T10:46:00.126][Rembus][1][Info] caronte up and running at port zmq:8002\n[2024-05-18T10:46:00.237][Rembus][1][Info] caronte up and running at port ws:8000\nThis finishes the setup, now you are ready to implements your Rembus components.\n\nTest broker services (RPC)\nThe caronte broker implements itself the version and uptime RPC services that unsurprisingly returns the broker version and the time in seconds since last reboot.\nThey may be used to check that caronte is up and running:\nusing Rembus\n\n@rpc version()\n\"0.2.0\"\n\n@rpc uptime()\n\"up for 15 seconds\"\n\n\nImplements a service (RPC)\nA component that implements a RPC service is just a Julia application that implements one ore more methods named as the service to be exposed.\nThe below example define the stats service that expects a dataframe as input and returns some statistics related to the value dataframe column.\nThe returned value is a Dictionary.\nusing Statistics\nusing Rembus\n\n# Return a stat summary of dataframes\n# values from the value column.\nfunction stats(df)\n    return Dict(\n        \"min\" =&gt; min(df.value...),\n        \"max\" =&gt; max(df.value...),\n        \"mean\" =&gt; mean(df.value),\n        \"std\" =&gt; std(df.value)\n    )\nend\n\n@expose stats\nThe @expose macro makes the stats method available to connected components.\nThe following example shows a Julia component that requests the stats service and in the Python section there is the equivalent request for a pandas dataframe.\n\n\nRequest a service (RPC)\nA client component that use the stats service will just a function call prefixed with @rpc:\nusing DataFrames\nusing Rembus\n\ndf = DataFrame(\n  :name=&gt;[\"kpi_$i\" for i in 1:5],\n  :ts=&gt;1:5, \n  :value=&gt;rand(5)\n)\n\nsummary = @rpc stats(df)"
  },
  {
    "objectID": "python.html",
    "href": "python.html",
    "title": "Python",
    "section": "",
    "text": "The rembus Python package provide both a synchronous and an asynchronous interface."
  },
  {
    "objectID": "python.html#getting-started",
    "href": "python.html#getting-started",
    "title": "Python",
    "section": "Getting Started",
    "text": "Getting Started\npip install rembus\nThen create a component object to interact with the others components:\n# sync API\nrb = rembus.component()\n\n# async API\nrb = await rembus.component()\nThe rb object provides methods for exposing functions implementation, for subscribing to topics, for message publishing and for service requests:\n\nrpc\npublish\nexpose\nsubscribe"
  },
  {
    "objectID": "python.html#request-a-service-rpc",
    "href": "python.html#request-a-service-rpc",
    "title": "Python",
    "section": "Request a service (RPC)",
    "text": "Request a service (RPC)\nThis example is a demo of requesting the service stats implemented in Julia.\n\nA python pandas dataframe is created;\nThe pandas dataframe is used as an argument of the rpc service stats;\nOn the RPC server side the stats method receive a Julia DataFrame;\nThe return value of stats is a Julia Dictionary;\nOn the client RPC side the response is a python dictionary.\n\nimport rembus.sync as rembus\nfrom random import random\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"name\": [f\"kpi_{i}\" for i in range(1,6)],\n    \"ts\": range(1,6),\n    \"value\": [random() for i in range(1,6)]\n})\n\nrb = rembus.component()\nsummary = rb.rpc(\"stats\", df)"
  }
]
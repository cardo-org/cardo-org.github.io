[
  {
    "objectID": "jsonrpc.html",
    "href": "jsonrpc.html",
    "title": "JSON-RPC",
    "section": "",
    "text": "Rembus fully supports the JSON_RPC 2.0 Specification"
  },
  {
    "objectID": "jsonrpc.html#rpc-request",
    "href": "jsonrpc.html#rpc-request",
    "title": "JSON-RPC",
    "section": "RPC Request",
    "text": "RPC Request\n\n\n\n\n\nflowchart LR\n  C((\"JSON-RPC\n  Client\")) --&gt; S((Julia Server))\n  style C fill:green, color:white\n  style S fill:blue, color:white\n\n\n\n\n\n\n\nServer ðŸ”µ - Exposing a service\nThe following (Julia) server exposes a method mymethod over an HTTP endpoint:\nusing Rembus\n\nfunction mymethod(;x, y, z) # expect to be called with keywords arguments\n    return Dict(\n        \"x\" =&gt; x,\n        \"y\" =&gt; y,\n        \"z\" =&gt; z,\n        \"op\" =&gt; \"x + y*z\",\n        \"value\" =&gt; x + y * z\n    )\nend\n\nrb = component(http=9000)\nexpose(rb, mymethod)\nwait(rb)\n\n\nJSON-RPC Client ðŸŸ¢\nWhen the server method requires keyword arguments, the JSON-RPC params field must be an object with matching keys:\ncurl -X POST http://localhost:9000 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"mymethod\",\n    \"params\": {\"x\": 1, \"y\": 2, \"z\": 3}\n  }'\nThe server responds with a JSON object encoding the Julia Dict returned by mymethod:\n{\n  \"id\":1,\n  \"jsonrpc\":\"2.0\",\n  \"result\": {\n    \"x\":1,\n    \"y\":2,\n    \"z\":3,\n    \"op\":\"x + y*z\",\n    \"value\":7\n  }\n}"
  },
  {
    "objectID": "jsonrpc.html#sending-notifications",
    "href": "jsonrpc.html#sending-notifications",
    "title": "JSON-RPC",
    "section": "Sending Notifications",
    "text": "Sending Notifications\nA JSON_RPC Notification is simply a Request object without an id field.\nIn Rembus, notifications map naturally to Pub/Sub messages: any published message is delivered to all subscribed components.\nIn this example, the topic is named mymethod.\n\nServer ðŸ”µ - Subscribing to a topic\nusing Rembus\n\nfunction mymethod(x, y, z)\n    println(\"mymethod called with x=$x, y=$y, z=$z\")\nend\n\nrb = component(http=9000)\nsubscribe(rb, mymethod)\n\n# Declare readiness to receive messages from subscribed topics,\n# in this case the topic mymethod.\nreactive(rb)\n\n# Start the event loop.\nwait(rb)\n\n\nJSON-RPC Publisher ðŸŸ¢\ncurl -X POST http://localhost:9000 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"mymethod\",\n    \"params\": [1,2,3]\n  }'"
  },
  {
    "objectID": "jsonrpc.html#batch",
    "href": "jsonrpc.html#batch",
    "title": "JSON-RPC",
    "section": "Batch",
    "text": "Batch\nTo send multiple requests in a single call, the client may submit an array of Request objects:\ncurl -X POST http://localhost:9000 \\\n  -H \"Content-Type: application/json\" \\\n  -d '[\n    {\n      \"jsonrpc\": \"2.0\",\n      \"method\": \"method1\",\n      \"params\": {\"x\": 1, \"y\": 2, \"z\": 3}\n    },{\n      \"jsonrpc\": \"2.0\",\n      \"method\": \"method2\",\n      \"params\": [\"mystring\", 1.0]\n    }\n  ]'"
  },
  {
    "objectID": "julia.html",
    "href": "julia.html",
    "title": "Julia",
    "section": "",
    "text": "Install the Rembus package and wait for the download and precompilation steps to complete:\njulia&gt; import Pkg; Pkg.add(\"Rembus\")\n   Resolving package versions...\n   Installed Rembus â”€ v1.0.0\n   ...\nPrecompiling project...\n  1 dependency successfully precompiled in 73 seconds. 72 already precompiled.\n\njulia&gt;"
  },
  {
    "objectID": "julia.html#getting-started",
    "href": "julia.html#getting-started",
    "title": "Julia",
    "section": "",
    "text": "Install the Rembus package and wait for the download and precompilation steps to complete:\njulia&gt; import Pkg; Pkg.add(\"Rembus\")\n   Resolving package versions...\n   Installed Rembus â”€ v1.0.0\n   ...\nPrecompiling project...\n  1 dependency successfully precompiled in 73 seconds. 72 already precompiled.\n\njulia&gt;"
  },
  {
    "objectID": "julia.html#rembus-node-types",
    "href": "julia.html#rembus-node-types",
    "title": "Julia",
    "section": "Rembus Node Types",
    "text": "Rembus Node Types\nRembus defines three node types:\n\n\nC\n Component: connects to a Broker or Server.\n\nB\n Broker: accepts connections and routes RPC and Pub/Sub messages between nodes.\n\nS\n Server: accepts connections from other nodes."
  },
  {
    "objectID": "julia.html#rembus-addressing",
    "href": "julia.html#rembus-addressing",
    "title": "Julia",
    "section": "Rembus Addressing",
    "text": "Rembus Addressing\nAddressing consists of two parts:\n\nThe name of a node;\nThe address of a remote node accepting connections;\n\nBoth are combined into a string that defines a node and its network link.\nExample: A Component named my_node connecting to a Broker listening on WebSockets at port 8000:\nrb = component(\"ws://localhost:8000/my_node\")\nRembus provides sensible defaults:\n\nProtocol: ws\nHost: 127.0.0.1\nPort: 8000\n\nSo the following is equivalent:\nrb = component(\"my_node\")"
  },
  {
    "objectID": "julia.html#rembus-hello-world",
    "href": "julia.html#rembus-hello-world",
    "title": "Julia",
    "section": "Rembus Hello World",
    "text": "Rembus Hello World\n\n\n\n\n\n\nflowchart LR\n  C((\"Client\")) --&gt; S((Server))\n  style C fill:#009E73, color:white\n  style S fill:#0072B2, color:white\n\n\n\n\n\n\n# ðŸ”µ server.jl\nusing Rembus\n\ngreet(who) = \"ciao $who\"\n\nrb = component(name=\"server\")\nexpose(rb, greet)\nwait(rb)\n# ðŸŸ¢ client.jl\nusing Rembus\n\nrb = component(\"client\")\n\nrpc(rb, \"greet\", \"mondo\")\nThe greet service accepts an argument of type Any. This means you can pass values other than strings:\nrpc(rb, \"greet\", 3.14))\nrpc(rb, \"greet\", [\"apple\", \"banana\"]))\nrpc(rb, \"greet\", Dict(\"name\"=&gt;\"duck\"))\nYou you want stricter data validation, declare argument types:\ngreet(who::AbstractString) = \"ciao $who\"\nNow only string arguments are accepted. Passing another type will raise a remote exception:\nrpc(rb, \"greet\", 3.14)\nERROR: RpcMethodException(\"greet\", \"MethodError(Main.greet, (3.14,), 0x...)\")"
  },
  {
    "objectID": "julia.html#handling-disconnections",
    "href": "julia.html#handling-disconnections",
    "title": "Julia",
    "section": "Handling Disconnections",
    "text": "Handling Disconnections\nRembus components automatically handle disconnection events.\nIf the server stops on the client side you have:\nisopen(rb)\nfalse\n\nrpc(rb, \"greet\", \"mondo\")\nERROR: connection down\nWhen the server restarts, the client handle reconnects in background:\nrpc(rb, \"greet\", \"mondo\")\n\"ciao mondo\""
  },
  {
    "objectID": "julia.html#publish-subscribe",
    "href": "julia.html#publish-subscribe",
    "title": "Julia",
    "section": "Publish-Subscribe",
    "text": "Publish-Subscribe\n\n\n\n\n\n\nflowchart LR\n  C((\"Publisher\")) --&gt; S1((Subscriber 1))\n  C((\"Publisher\")) --&gt; S2((Subscriber 2))\n  style C fill:#009E73, color:white\n  style S1 fill:#0072B2, color:white\n  style S2 fill:#0072B2, color:white\n\n\n\n\n\n\n\nSubscriber 1\n# ðŸ”µ sub-1.jl\nusing Rembus\n\nmytopic(data) = println(\"[Sub-1] mytopic:$data\")\n\nfoo() = \"sub-1.jl\"\n\nrb = component(name=\"sub-1\", ws=3001)\nsubscribe(rb, mytopic)\nexpose(rb, foo)\n\nprintln(\"up and running\")\nwait(rb)\n\n\nSubscriber 2\n# ðŸ”µ sub-2.jl\nusing Rembus\n\nmytopic(data) = println(\"[Sub-2] mytopic:$data\")\n\nfoo() = \"sub-2.jl\"\n\nrb = component(name=\"sub-2\", ws=3002)\nsubscribe(rb, mytopic)\nexpose(rb, foo)\n\nprintln(\"up and running\")\nwait(rb)\n\n\nPublisher 1\n# ðŸŸ¢ publish.jl\nusing Rembus\n\nrb = component([\n  \"ws://:3001/client\",\n  \"ws://:3002/client\"\n])\n\nsensor1 = Dict(\n  \"T\" =&gt; 18.3, \"H\" =&gt; 45.2\n)\nsensor2 = Dict(\n  \"P\" =&gt; 2.3\n)\n\npublish(\n    rb,\n    \"mytopic\",\n    Dict(\n        \"sensor#1\" =&gt; sensor1,\n        \"sensor#2\" =&gt; sensor2,\n    )\n)"
  },
  {
    "objectID": "julia.html#a-simple-broker-example",
    "href": "julia.html#a-simple-broker-example",
    "title": "Julia",
    "section": "A simple Broker example",
    "text": "A simple Broker example\n\n\n\n\n\n\nflowchart LR\n  C((\"Client\")) --&gt; B((Broker))\n  B --&gt; S((Server))\n  style C fill:#009E73, color:white\n  style B fill:#F0E442, color:black\n  style S fill:#0072B2, color:white\n\n\n\n\n\n\n\n\nB\n Broker\nRun the \nB\n broker from the terminal:\nshell&gt; julia -e 'using Rembus; Rembus.brokerd()'\nOr in the REPL:\nusing Rembus\n\nrb = component()\nBy default the broker accepts WebSocket connections on port 8000. Other endpoints (TCP, ZeroMQ, HTTP) are also supported:\njulia -e 'using Rembus; Rembus.brokerd()' -- --ws 8000 --tcp 8001 --zmq 8002 --http 9000\n[ Info: [serve_http] starting at port 9000\n[ Info: Listening on: 0.0.0.0:9000, thread id: 1\nOr in the REPL:\nusing Rembus\n\nrb = component(ws=8000, tc=8001, zmq=8002, http=9000)\nIf the http endpoint is active you can check that the broker is up and running with JSON-RPC:\nsh&gt; curl -X POST http://localhost:9000 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\":\"2.0\",\"method\":\"uptime\",\"id\":\"1234\"}'\n\nsh&gt; {\"id\":\"1234\",\"jsonrpc\":\"2.0\",\"result\":\"up for 15 seconds\"}  \n\n\n\nS\n Server\nA server component exposes RPC services by defining functions.\nExample: a stats service for a DataFrame:\nusing Statistics\nusing Rembus\n\n# Return a stat summary of dataframes\n# values from the value column.\nfunction stats(df)\n    return Dict(\n        \"min\" =&gt; min(df.value...),\n        \"max\" =&gt; max(df.value...),\n        \"mean\" =&gt; mean(df.value),\n        \"std\" =&gt; std(df.value)\n    )\nend\n\n@expose stats\nThe @expose macro makes the stats method available to other components.\nThe following example shows a Julia component that requests the stats service and in the Python section there is the equivalent RPC request for a pandas dataframe.\n\n\n\nC\n Client\nA client can call stats using @rpc:\nusing DataFrames\nusing Rembus\n\ndf = DataFrame(\n  :name=&gt;[\"kpi_$i\" for i in 1:5],\n  :ts=&gt;1:5, \n  :value=&gt;rand(5)\n)\n\nsummary = @rpc stats(df)\nAs a side note keep in mind that the broker implements the version and uptime RPC services that unsurprisingly returns the broker version and the time in seconds since last reboot.\nThey may be useful when a \nC\n client wants to verify that the \nB\n broker is up and running:\nusing Rembus\n\n@rpc version()\n\"0.2.0\"\n\n@rpc uptime()\n\"up for 15 seconds\""
  },
  {
    "objectID": "julia.html#brokers-in-series",
    "href": "julia.html#brokers-in-series",
    "title": "Julia",
    "section": "Brokers in Series",
    "text": "Brokers in Series\n\n\n\n\n\nflowchart LR\n  C((\"Client\")) --&gt; B1((Broker1))\n  B1 --&gt; B2((Broker2))\n  B2 --&gt; S((Server))\n  style C fill:#009E73, color:white\n  style B1 fill:#F0E442, color:black\n  style B2 fill:#F0E442, color:black\n  style S fill:#0072B2, color:white\n\n\n\n\n\n\n# ðŸŸ¢ client.jl\nusing Rembus\n\nrb = component(\"ws://localhost:3001/cli\")\nresponse = rpc(rb, \"foo\", 12.0)\n\nclose(rb)\n# ðŸŸ¡ broker1.jl\nusing Rembus\n\nrb = component(\"ws://localhost:3002/broker1\", ws=3001)\nwait(rb)\n# ðŸŸ¡ broker2.jl\nusing Rembus\n\nrb = component(ws=3002)\nwait(rb)\n# ðŸ”µ server.jl\nusing Rembus\n\nfoo(x) = 2x\n\nrb = component(\"ws://localhost:3002/srv\")\nexpose(rb, foo)\n\nwait(rb)\nterminal-1&gt; j broker-1.jl\nterminal-2&gt; j broker-2.jl"
  },
  {
    "objectID": "julia.html#brokers-in-parallel",
    "href": "julia.html#brokers-in-parallel",
    "title": "Julia",
    "section": "Brokers in Parallel",
    "text": "Brokers in Parallel\n\n\n\n\n\nflowchart LR\n  C((\"Client\")) --&gt; B1((Broker1))\n  C((\"Client\")) --&gt; B2((Broker2))\n  B1 --&gt; S((Server))\n  B2 --&gt; S((Server))\n  style C fill:#009E73, color:white\n  style B1 fill:#F0E442, color:black\n  style B2 fill:#F0E442, color:black\n  style S fill:#0072B2, color:white\n\n\n\n\n\n\n# ðŸŸ¢ client.jl\nusing Rembus\n\nrb = component([\"ws://localhost:3001/cli\", \"ws://localhost:3002/cli\"])\n\nrpc(rb, \"foo\", 1.0)\n# ðŸŸ¡ broker1.jl\nusing Rembus\n\nrb = component(ws=3001)\nwait(rb)\n# ðŸŸ¡ broker2.jl\nusing Rembus\n\nrb = component(ws=3002)\nwait(rb)\n# ðŸ”µ server.jl\nusing Rembus\n\nfoo(x) = 2x\n\nrb = component([\"ws://localhost:3001/srv\", \"ws://localhost:3002/srv\"])\nexpose(rb, foo)\n\nwait(rb)"
  },
  {
    "objectID": "julia.html#security",
    "href": "julia.html#security",
    "title": "Julia",
    "section": "Security",
    "text": "Security\nRembus Authentication supports:\n\nRSA digital signature\nECDSA digital signature\nShared secret (plaintext)\n\nAutorization is based on private topics accessible only to entitled components.\nThe register/unregister methods handle automatic provisioning and deprovisioning.\nSee the Security documentation for details."
  },
  {
    "objectID": "julia.html#settings",
    "href": "julia.html#settings",
    "title": "Julia",
    "section": "Settings",
    "text": "Settings\nRembus behavior is configurable via environment variables and settings.json file.\nThese control parameters such as:\n\nData directory location\nMessage timeouts\nKeep-alives\nConnection handling\n\nSee the Configuration for more details."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rembus",
    "section": "",
    "text": "The goal of Rembus is to be a messaging middleware for systems where the mains building blocks are scientific computing and components decoupling using microservices architectural patterns.\nIt is written in Julia but designed to exchange messages between components implemented in other languages.\nIt is a fresh approach to messaging: instead of requiring buffers or streams of bytes and loading the application with encoding/decoding tasks it accepts primitive types, dictionaries, lists and dataframes types through a thin API."
  },
  {
    "objectID": "index.html#rpc",
    "href": "index.html#rpc",
    "title": "Rembus",
    "section": "RPC",
    "text": "RPC\nRembus provides the request/reply pattern where a component request a service and another component implements and exposes such service.\nThere may be multiple components exposing the same service and different logics for routing the request to a specific server, implementing fail-over or balancing features."
  },
  {
    "objectID": "index.html#publishsubscribe",
    "href": "index.html#publishsubscribe",
    "title": "Rembus",
    "section": "Publish/Subscribe",
    "text": "Publish/Subscribe\nOne component produce a message and one or many interested subscribers receive it.\nWhen a component goes online again if the retroactive feature is enabled the component receives the messages published when it was offline."
  },
  {
    "objectID": "index.html#brokerless",
    "href": "index.html#brokerless",
    "title": "Rembus",
    "section": "Brokerless",
    "text": "Brokerless\nIn a simple scenario or where a Broker may be redundant or tought as a single point of failure a brokerless architecture consents peer to peer comunication between components."
  },
  {
    "objectID": "index.html#dataframes-support",
    "href": "index.html#dataframes-support",
    "title": "Rembus",
    "section": "DataFrames support",
    "text": "DataFrames support\nRembus uses the Arrow columnar format to transport dataframes messages between components.\nJulia and Python components may exchange dataframes betweeen DataFrames.jl, Pandas and Polars libraries."
  },
  {
    "objectID": "python.html",
    "href": "python.html",
    "title": "Python",
    "section": "",
    "text": "Install rembus with pip or uv:\npip install rembus\nuv add rembus\nThen create a component object to interact with the others components:\n# sync API\nrb = rembus.node()\n\n# async API\nrb = await rembus.component()\nThe rb object provides methods for exposing functions implementation, subscribing to topics, publishing messages and requesting services:\n\nrpc\npublish\nexpose\nsubscribe"
  },
  {
    "objectID": "python.html#getting-started",
    "href": "python.html#getting-started",
    "title": "Python",
    "section": "",
    "text": "Install rembus with pip or uv:\npip install rembus\nuv add rembus\nThen create a component object to interact with the others components:\n# sync API\nrb = rembus.node()\n\n# async API\nrb = await rembus.component()\nThe rb object provides methods for exposing functions implementation, subscribing to topics, publishing messages and requesting services:\n\nrpc\npublish\nexpose\nsubscribe"
  },
  {
    "objectID": "python.html#rpc",
    "href": "python.html#rpc",
    "title": "Python",
    "section": "RPC",
    "text": "RPC\n\n\n\n\n\nflowchart LR\n  C((\"Client\")) --&gt; S((Server))\n  style C fill:#009E73, color:white\n  style S fill:#0072B2, color:white\n\n\n\n\n\n\nIn this example a RPC request is made for the service stats which is implemented in a Julia \nS\n server:\n# ðŸ”µ stats.jl\nusing Statistics\nusing Rembus\n\n# Return a stat summary of dataframes\n# values from the value column.\nfunction stats(df)\n    return Dict(\n        \"min\" =&gt; min(df.value...),\n        \"max\" =&gt; max(df.value...),\n        \"mean\" =&gt; mean(df.value),\n        \"std\" =&gt; std(df.value)\n    )\nend\n\nrb = component()\n\nexpose(rb, stats)\n\nprintln(\"up and running\")\nwait(rb)\nThe python \nC\n client creates a pandas DataFrame and requests the stats service:\n# ðŸŸ¢ client.py\nimport rembus\nfrom random import random\nimport pandas as pd\n\nnrows = 1000000 \ndf = pd.DataFrame({\n    \"name\": [f\"kpi_{i}\" for i in range(1,nrows)],\n    \"ts\": range(1,nrows),\n    \"value\": [random() for i in range(1,nrows)]\n})\n\nrb = rembus.node()\nsummary = rb.rpc(\"stats\", df)\nThe sequence of steps is:\n\nOn the \nC\n client side a python pandas dataframe is created and used as argument of the rpc method;\nOn the \nS\n server side the stats method is called with a Julia DataFrame as argument;\nOn the \nS\n server side the return value of stats is a Julia Dictionary;\nOn the \nC\n client side the response is a Python dictionary."
  },
  {
    "objectID": "python.html#publish-subscribe",
    "href": "python.html#publish-subscribe",
    "title": "Python",
    "section": "Publish-Subscribe",
    "text": "Publish-Subscribe\n\n\n\n\n\n\nflowchart LR\n  C((\"Publish\")) --&gt; S1((Sub-1))\n  C((\"Publish\")) --&gt; S2((Sub-2))\n  style C fill:#009E73, color:white\n  style S1 fill:#0072B2, color:white\n  style S2 fill:#0072B2, color:white\n\n\n\n\n\n\n# ðŸ”µ sub-1.py\nimport rembus\n\ndef mytopic(data):\n    println(\"[Sub-1] mytopic:$data\")\nend\n\nrb = await component(name=\"sub-1\")\nawait subscribe(rb, mytopic)\nawait wait(rb)\n# ðŸ”µ sub-2.jl\nimport rembus\n\ndef mytopic(data):\n    print(f\"[Sub-2] DB update: {data}\")\n\nrb = rembus.node(name=\"sub-2\")\nrb.subscribe(mytopic)\nrb.wait()\n# ðŸŸ¢ publish.jl\nusing Rembus\n\nrb = component([\n  \"ws://:3001/client\",\n  \"ws://:3002/client\"\n])\n\nsensor1 = Dict(\n  \"T\" =&gt; 18.3, \"H\" =&gt; 45.2\n)\nsensor2 = Dict(\n  \"P\" =&gt; 2.3\n)\n\npublish(\n    rb,\n    \"mytopic\",\n    Dict(\n        \"sensor#1\" =&gt; sensor1,\n        \"sensor#2\" =&gt; sensor2,\n    )\n)"
  }
]